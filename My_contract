// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;
// this is a way we acces variable
// contract  Identity{
//     string name;
//     uint age;
//     constructor(){
//         name="rahul";
//         age=12;
//     }
//     function getname() public view returns(string memory){
//         return name;
//     }
//       function getage() public view returns(uint){
//         return age;
//     }
//     function setage() public {
//         age=age+1;
//     }
// }
// STATE VARIABLE
// state variable are those variable which are create on the contract directy not inside the function when  we create it they are store in the blockchain directly due to this we pay high gas frees 
// contract state{
//     uint public age;

// }
// we cannot assign the value of the variable in the function diecty 1 we have to compile then deploy then the button is create 
// state variable are not dynamically allocated
// we can assign value to the state variable in 3 ways 
// 1. directly assign  uint public age =10;
// age=10 this is give error we cannot declare like this 
// 2.by constructor constructor{
//     age=10;
// }
// 3.by setfunction by create function ex function setvariable() public {
//     age=10;
// }
// LOCAL VARIABLE
// In Solidity, local variables are variables that are declared inside functions and are only accessible within the function where they are defined
//  they are store in stack not store in blockchain
// contract local
// {
// function localvar() pure public returns(uint){
// string memory name ="ravi";
// uint age=10;
// return age;
// }
// }
// FUNCTION GETTER AND FUNCTION
// contract FUN {
//     uint public age=10;
//     function getter() public view returns(uint) {
// return age;
//     }
    // increament the value
    // function setter() public  {
    //     age=age+1;
    // }
    // passing argument
    // function setter(uint newage) public  {
    //     age=newage;
    // // }
    // we have to pay the gas in the settter function becz we make changes in the blockchain so we have to pay some gas.
    // while in getter we dont bring any change so there is no gas fees in this
    // imp****************** when we declare the public in the state then we dont have to create the the getter function of that variable becz we initilize the public which automatically create the getter function
}
// constructor
// contract local {
//     uint public count;
//     constructor(uint counts){
//         count=counts;
//     }
// }
//execute only once
// you can create only one constructor and that is optional
// a default constructor is created by the compiler if there is no explicity define 
// Integers
// int=-+ uint=+ 
// size 8 to 256 int
// size 8 to 256 uint
// when we used int in our solidity we indirectly assign the 256
// same as uint we indirectly assign 256
// multiple of 8
// by default int is initilize to 0
// overflow get detected at compile time
// range int8 -128 to +127 and int16 -32768 to +32767
// uint 0to255 and uint16 0 to 65535
//  formula integers -2^(n-1) to 2^(n-1)-1  where n is number of bit
//  formula for unsign integern 0 to 2^(n)-1  where n is number of bit
// contract values1{
//     int8 count =127;
//     uint8 count1=25;

// }
// this is big problem of overflow
// some basic opoertor are used 
// <=,<,==,!=,>=,>(evaluate to bool)
// bit operator &,|,^(bitwise exclusive or),bitwise 
// overflow and underflow
// read on article
// contract local1{
// uint public  money=255;
// function setter() public {
//     money=money+1;
// }
// }
// in the version 0.5.0 we got value 0 which is very dangerous in the programming. for more detail kindly read the article
// ARRAYS
// there are two type array in solidity 1 fixed size array and the other is 2 dynamic size array
// fixed size
// compile time par array ki size define kar ni padhi ti ha that is why this is fixed size array
//  contract arraylen{
// uint[4] public arr=[10,20,30,40];
// function setter(uint index,uint value) public{
//     arr[index]=value;
// }
// this is a way we can calculate the length of array
// function length() public view returns(uint len){
//     return arr.length;
// }
// }
// we can access the  value after deploy and we pass the index of that
// Dynamic size array
// contract dynamicarr{
// uint[] public arr;
// function pushelement(uint item) public {
// arr.push(item);
// }
// function lenarr() public view returns(uint){
// return arr.length;
// }
// function popfunc() public {
//     arr.pop();
// }
// }
// BYTE ARRAYS
// 1 byte=8bits
// 1 hex digit=4 bits
// everything that will be stored in the byte array will be in the form of hexadecimal digits
// contract array{
//     bytes3 public b3; 
//     bytes2 public b2;
//     function setter() public  {
//         b2="ab";
//         b3="abc";
//     }
// }
// bytes3 this is a way we create a array in the 3 means 3*8=24bits
// asci value are assign to the abc=616263
//  if we assign the value more than b3 like abcd this will give me error 
// if we assignt the b2 like this"a" value size is less than so 0 is assign
// byte array is in mutable

